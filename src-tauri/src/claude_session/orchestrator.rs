use std::path::Path;

use crate::git_ops::{
    branch::{create_feature_branch, generate_branch_name},
    cleanup::cleanup_session_dir,
    clone::clone_to_temp,
    commit::commit_and_push,
    pr::create_pull_request,
};

use super::process::{compose_instructions, run_claude_and_wait, ProcessError};

#[derive(Debug)]
pub enum OrchestratorError {
    GitError(String),
    ProcessError(ProcessError),
    IoError(std::io::Error),
}

impl std::fmt::Display for OrchestratorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            OrchestratorError::GitError(msg) => write!(f, "Git error: {}", msg),
            OrchestratorError::ProcessError(e) => write!(f, "Process error: {}", e),
            OrchestratorError::IoError(e) => write!(f, "IO error: {}", e),
        }
    }
}

impl From<crate::git_ops::GitOpsError> for OrchestratorError {
    fn from(e: crate::git_ops::GitOpsError) -> Self {
        OrchestratorError::GitError(e.to_string())
    }
}

impl From<ProcessError> for OrchestratorError {
    fn from(e: ProcessError) -> Self {
        OrchestratorError::ProcessError(e)
    }
}

impl From<std::io::Error> for OrchestratorError {
    fn from(e: std::io::Error) -> Self {
        OrchestratorError::IoError(e)
    }
}

pub struct SessionConfig {
    pub session_id: String,
    pub git_directory: String,
    pub user_instructions: String,
    pub additional_instructions: Option<String>,
    pub instructions_file_content: Option<String>,
    pub base_branch: String,
}

pub struct SessionResult {
    pub pr_url: String,
    pub branch_name: String,
}

pub fn run_full_session(config: SessionConfig) -> Result<SessionResult, OrchestratorError> {
    let source_path = Path::new(&config.git_directory);

    let work_dir = clone_to_temp(source_path, &config.session_id)?;

    let branch_name = generate_branch_name(&config.user_instructions);
    create_feature_branch(&work_dir, &branch_name)?;

    let instructions = compose_instructions(
        &config.user_instructions,
        config.additional_instructions.as_deref(),
        config.instructions_file_content.as_deref(),
    );

    run_claude_and_wait(&work_dir, &instructions)?;

    let commit_message = format!("feat: {}", config.user_instructions);
    commit_and_push(&work_dir, &commit_message)?;

    let pr_title = config.user_instructions.clone();
    let pr_body = format!(
        "## Summary\n\nThis PR was generated by Claude via the Dreamal `/claude` macro.\n\n## Instructions\n\n{}\n",
        config.user_instructions
    );

    let pr_url = create_pull_request(&work_dir, &pr_title, &pr_body, &branch_name, &config.base_branch)?;

    cleanup_session_dir(&work_dir)?;

    Ok(SessionResult { pr_url, branch_name })
}

pub fn cleanup_failed_session(session_id: &str) -> Result<(), OrchestratorError> {
    use crate::git_ops::cleanup::cleanup_session;
    cleanup_session(session_id)?;
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_session_config_creation() {
        let config = SessionConfig {
            session_id: "test-123".to_string(),
            git_directory: "/path/to/repo".to_string(),
            user_instructions: "Add dark mode".to_string(),
            additional_instructions: Some("Use CSS variables".to_string()),
            instructions_file_content: None,
            base_branch: "main".to_string(),
        };

        assert_eq!(config.session_id, "test-123");
        assert_eq!(config.user_instructions, "Add dark mode");
    }

    #[test]
    fn test_session_result_creation() {
        let result = SessionResult {
            pr_url: "https://github.com/owner/repo/pull/1".to_string(),
            branch_name: "claude/add-dark-mode-123".to_string(),
        };

        assert!(result.pr_url.contains("github.com"));
        assert!(result.branch_name.starts_with("claude/"));
    }
}
